# DrWeb-CTF2024-EverlastingReverse
## Writeup [ru]

![image](https://github.com/user-attachments/assets/87dfe27d-01e8-46a0-b923-2f2686728d4a)

В архиве лежит exeшник и файл с расширением .pck.
Запускаем приложение, видим, что перед нами программа, написанная на godot движке:

![godotConsole](https://github.com/user-attachments/assets/1eaa2b09-f5e9-41e5-8046-4ec6b53a1e58)


![image](https://github.com/user-attachments/assets/f28aff06-07cc-40de-b27f-9079a4318747)

Т.к. перед нами Godot, попробуем восстановить все файлы и сам проект из архива game.pck через GDRE Tools.
Однако архив запаролен... Требуется найти 256 битный ключ(32 байта)

В описании задания есть подсказка на то, что мы имеем дело с опенсорсным проектом. Так оно и есть - исходный код движка godot есть на гитхабе.
Параллельно гуглим запросы по типу: "how to extract the project key from godot application"
1я ссылка наталкивает нас на статью о ненадежности функции open_and_parse, которая открывает наш защищенный .pck файл, используя ключ в открытом виде.

![image](https://github.com/user-attachments/assets/2fa85b5e-b177-4077-92eb-4af380d7e7fe)

Находим исходный код функции в репозитории godot движка. Отсюда можно взять строки, по которым можно найти эту функцию в коде программы, а также
посмотреть на аргументы функции

![image](https://github.com/user-attachments/assets/8f408308-5dc4-41c2-a7f7-ecf778669842)

### Статический анализ.
Detect It Easy дает нам понять, что программа упакована(энтропия + нестандартное имя секции файла):

![image](https://github.com/user-attachments/assets/661053d0-0ec6-45d7-b165-c9f6d23f58a8)

Благо анти-дампа нет(установленно опытным путем), дампим прогу, к примеру, с помощью scylla-plugin.
После снятия дампа, находим по строкам искомую функцию и вычисляем ее оффсет относительно базы. Оффсет равен 0xb00ef0.

![image](https://github.com/user-attachments/assets/acc82f9f-c72f-44b0-b274-aadb44a1f62c)

### Динамический анализ.
Попробуем протрассировать вызов API функций, используемых приложением.
Посмотрим, какие API-функции оперируют с файлом game.pck и натыкаемся на функцию RtlDosPathNameToRelativeNtPathName_U.

![image](https://github.com/user-attachments/assets/06143daf-ba27-4f98-8249-41b7952f6bfe)

Вызов этой функции происходит раньше, чем происходит исполнение кода функции open_and_parse, а также функция вызывается после распаковки кода приложения, поэтому самый простой способ - остановиться на ней.
ставим на нее бряку в APIMonitor, ждем 3го отловленного вызова функции(ближайший к функции open_and_parse),  перезапускаем трассировку и аттачимся x64dbg к исследуемому процессу.
В x64dbg ставим бряк на функцию open_parse.

![image](https://github.com/user-attachments/assets/01ced880-2352-48c6-bddc-2d0b720aaeac)

После передачи управления нашему отладчику, падаем в бесконечный цикл, пораждающий каждый раз сложное исключение через int3, которое отлавливается обработчиком apiMonitor'a 

![image](https://github.com/user-attachments/assets/e956aee6-3392-40f4-9aee-0ea415a31a6c)

Достаточно просто переместить rip на 1 инструкцию вперед - "перешагнуть через int3" - и пару раз прожать f9(не вникал в работу обработчика apiMonitor'a, однако это работает)
в итоге попадаем на функцию open_and_parse

![image](https://github.com/user-attachments/assets/c5b2463d-6447-4255-ae05-be54beb123d2)

В регистре r8 будет лежать указатель на вектор, содержащий наш ключ

![image](https://github.com/user-attachments/assets/700ed5dd-2965-41ef-9a26-d4096f542a89)

Восстановив проект, можно поменять параметр  pc_defeated, о котором говорится на картинке в начале райтапа и пересобрать проект, однако лично у меня не получилось из-за кривого восстановления проекта через gdre tools.
Пришлось руками восстановить переменные k и v для декрипта флага. К счастью, это заняло 5 минут : )

![image](https://github.com/user-attachments/assets/2a18c845-4619-4cb7-b10a-a7204a79741c)

k = base_cool_spider_thinking_screen (key)
v = Black_spider (nonce)

Осталось дешифровать флаг. Зайдем в файл CHACHA.gd, находившийся внутри проекта и где есть описание метода decrypt_hex, посмотрим на используемые параметры метода

![image](https://github.com/user-attachments/assets/884f9425-75a0-4688-a66b-79b23374ded1)

ChaCha.decrypt_hex, помимо зашифрованного сообщения, ключа и nonce, использует 20 раундов а также начальное значение счетчика = 1

Найдя все необходимые значения, декодируем наш флаг:

![image](https://github.com/user-attachments/assets/7925090d-89ad-4105-9ea4-e4a0c25cae89)

